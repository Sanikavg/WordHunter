# WordHunter

ABOUT THE GAME

"Word Hunter" is a thrilling text-based game that challenges players to embark on an adventure in pursuit of hidden letters. The game is designed to test and enhance players' puzzle-solving skills. The setting of the game is Rooms surrounded by water.

CONTENTS OF THE GAME

-	9 Rooms: ballroom, bar, billiardRoom, library, bedroom, lounge, dining, kitchen, magicTransporter
-	9 Items: glass, cue, ball, book, pillow, bag, candlestick, knife, pan
-	4 Characters: chef, bartender, waiter, librarian
-	8 Words: LIFE, LOVE, LIVE, FEAR, REAL, FAIR, SAVE, SAFE
-	9 Letters: L, I, O, V, A, E, R, S, F
-	1 Player


<img width="635" alt="Screenshot 2025-06-03 at 12 55 31" src="https://github.com/user-attachments/assets/738f5f71-b532-4405-9be1-58b7cb51536c" />
















HOW TO PLAY

You start the game in the ballroom. You are given a word at the start of the game. You must find the items that contain the letters, that you need to complete your word. Remember, all items need to be dropped in your starting room, the ballroom. Every item contains one letter. The items are in different rooms. To find the items, you need to visit the rooms. Pick one or more items from the room, exit the room, and ultimately drop the items in the ballroom. Warning: If you exit a room with total weight of more than 1000 grams on you, you will drown. Hence, to save you, the game will not allow you to exit the room with more than 1000 grams. Beware: some of the rooms have characters waiting for you with a special surprise. The surprise could either give you an advantage in the game or it could change the entire course of your game. It is for you to decide to take the risk and avail the surprise. Once you have gathered all the required items in the ballroom, you will have successfully won the game.


FEATURES and Commands

Items
-	‘PICK’ - Pick an item
-	‘DROP’ - Drop an item
-	‘MOVE’ Move an item from one room to another

Characters
-	‘GET’ - Receive a message from a character

Rooms
-	‘GO’ - Go from one room to another by looking up its exits
-	‘BACK’ - Go back to your previously visited rooms

Extras
-	‘QUIT’ – quit the game
- ‘HELP’ – to receive help


BASE TASKS

-	Creation of 9 locations by creating 9 new objects of the Room class.
-	Creation of 9 items by creating 9 new objects of the Item class and place either 0, 1 or 2 items in every room.
-	Every item is assigned a weight value, and the player has a restriction of carrying maximum 1000 grams at one time.
-	For each time the player wants to pick an item, the game compares the (total weight + current item weight) value with 1000. If lower, it allows the user to pick the item.
-	The player wins if the player has successfully collected all items, that contain the letters to complete the word, in the ballroom.
-	Every time the player enters a room, it is added to the list of visited rooms. The back command checks for the second last room added in the visited Rooms list and lets the player enter that room. If the player’s last visited room is the ballroom, the game informs the user that they are back in their starting location.
-	The four new commands added are: pick, drop, move, get.


Challenge TASKS
-	Creation of 4 characters by creating 4 new objects of the Character class. Assign the character a random room. Every time a player meets a character, the player can avail a surprise.
-	Edit the Parser and Command class to recognize three-word command “move item room”.
-	Every time a player enters the magic transporter room, they are sent to a random room generated by the random generator.


Code Quality Considerations

-	Coupling: My program consists of 8 classes that communicate with each other through well-defined interfaces rather than directly accessing each other's internal details, thus making it easier to modify or replace one module without affecting others.
-	Cohesion: To enhance cohesion, I organize the utility functions based on their functionality.
-	Responsibility-driven design: I follow a responsibility-driven design approach by assigning specific responsibilities to different components. For instance, there is one class responsible for parsing, another for creating characters, rooms, items, and yet another for the actual implementation of the game. Each module has a clear responsibility, making it easier to understand, test, and modify.
-	Maintainability: To ensure maintainability, I adopt practices such as thorough code documentation and a well-organized code structure. All modules, classes, and functions are documented, explaining their purpose, inputs, outputs, and usage. Additionally, I use clear naming conventions and follow a modular structure.

